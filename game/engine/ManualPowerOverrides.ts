/**
 * Manual Power Overrides - SINGLE LOCATION FOR SHIP-SPECIFIC LOGIC
 * 
 * PURPOSE:
 * This is the ONLY place where ship-specific power logic may live.
 * Used when a power has neither:
 *   - effectAst (structured interpretation)
 *   - kind (effect type classification)
 * 
 * RULES:
 * - Keyed by: shipId → powerIndex
 * - Must be explicitly documented
 * - Should be minimal (prefer AST or kind when possible)
 * - No CSV text parsing here
 * 
 * ARCHITECTURE:
 * This is a fallback system. Most ships should eventually have:
 *   1. AST interpretation (ideal)
 *   2. Effect kind classification (good)
 *   3. Manual override (last resort)
 */

import type { GameState, PlayerShip } from '../types/GameTypes';
import type { EngineShipPower, ShipDefId } from '../types/ShipTypes.engine';
import type { TriggeredEffect } from '../types/EffectTypes'; // LEGACY EFFECTS — migrate to /game/engine/effects/ when touching this file
import { 
  EffectKind, 
  createTriggeredEffect, 
  generateEffectId,
  createSelfTarget,
  createOpponentTarget 
} from '../types/EffectTypes'; // LEGACY EFFECTS — migrate to /game/engine/effects/ when touching this file

// ============================================================================
// TYPES
// ============================================================================

export interface PowerExecutionContext {
  gameState: GameState;
  ship: PlayerShip;
  ownerId: string;
  opponentId: string;
  currentPhase: any;
  currentTurn: number;
  diceRoll?: number;
}

export interface ManualPowerResult {
  /** Updated game state */
  gameState: GameState;
  
  /** Effects generated by this power */
  effects?: TriggeredEffect[];
  
  /** Whether player choice is required */
  requiresChoice?: boolean;
  
  /** Description of what happened */
  description?: string;
}

export type ManualPowerHandler = (
  power: EngineShipPower,
  context: PowerExecutionContext
) => ManualPowerResult;

// ============================================================================
// MANUAL OVERRIDE REGISTRY
// ============================================================================

/**
 * Registry of manual power handlers
 * Key format: `${shipId}_${powerIndex}`
 * 
 * USAGE:
 * Only add entries here when:
 * 1. Power has complex conditional logic that can't be expressed in AST
 * 2. Power has cross-turn state requirements
 * 3. Power requires special validation
 * 
 * PREFER:
 * - Setting power.kind in ShipDefinitions.engine.ts for simple powers
 * - Adding effectAst for structured interpretation
 */
const MANUAL_OVERRIDES: Record<string, ManualPowerHandler> = {
  
  // -------------------------------------------------------------------------
  // HUMAN SHIPS
  // -------------------------------------------------------------------------
  
  // FRIGATE (FRI) - Trigger number mechanic
  'FRI_0': (power, context) => {
    // First power: "Choose a trigger number for this ship, 1-6"
    // This is handled during drawing phase, requires player interaction
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose trigger number (1-6)'
    };
  },
  
  'FRI_1': (power, context) => {
    // "If dice roll matches the trigger number, deal 6 damage"
    const { ship, diceRoll, gameState, ownerId } = context;
    
    // Check if trigger number is set and matches
    const triggerNumber = ship.customState?.frigateTargetNumber;
    if (!triggerNumber || diceRoll !== triggerNumber) {
      return { gameState };
    }
    
    // Generate damage effect
    const effect = createTriggeredEffect({
      id: generateEffectId(
        {
          sourcePlayerId: ownerId,
          sourceShipInstanceId: ship.id,
          sourceShipDefId: ship.shipId,
          sourcePowerIndex: power.powerIndex,
          sourceType: 'ship_power'
        },
        EffectKind.DAMAGE,
        gameState.roundNumber,
        0
      ),
      kind: EffectKind.DAMAGE,
      source: {
        sourcePlayerId: ownerId,
        sourceShipInstanceId: ship.id,
        sourceShipDefId: ship.shipId,
        sourcePowerIndex: power.powerIndex,
        sourceType: 'ship_power'
      },
      target: createOpponentTarget(ownerId, gameState.players),
      value: 6,
      description: `Frigate trigger hit! (dice: ${diceRoll})`
    });
    
    return {
      gameState,
      effects: [effect],
      description: `Frigate triggered on ${diceRoll}`
    };
  },
  
  // SCIENCE VESSEL (SCI) - Conditional based on count
  'SCI_0': (power, context) => {
    // "If you have 1 Science Vessel: Double your Automatic healing"
    // This is a passive modifier, not an executable power
    // Handled by PassiveModifiers system
    return { gameState: context.gameState };
  },
  
  'SCI_1': (power, context) => {
    // "If you have 2 Science Vessels: Double your Automatic damage"
    // This is a passive modifier, not an executable power
    return { gameState: context.gameState };
  },
  
  'SCI_2': (power, context) => {
    // "If you have 3 Science Vessels: Generate additional lines equal to the dice roll"
    // This would execute during line generation if count === 3
    const { gameState, ownerId, diceRoll } = context;
    
    // Count science vessels
    const scienceVesselCount = (gameState.gameData.ships?.[ownerId] || [])
      .filter(s => s.shipId === 'SCI' && !s.isDestroyed && !s.isConsumedInUpgrade)
      .length;
    
    if (scienceVesselCount < 3 || !diceRoll) {
      return { gameState };
    }
    
    // Add lines immediately (not health, so safe)
    const updatedState = {
      ...gameState,
      players: gameState.players.map(p =>
        p.id === ownerId
          ? { ...p, lines: (p.lines || 0) + diceRoll }
          : p
      )
    };
    
    return {
      gameState: updatedState,
      description: `Science Vessel x3: +${diceRoll} lines`
    };
  },
  
  // DREADNOUGHT (DRE) - Complex trigger logic
  'DRE_0': (power, context) => {
    // "When you complete a ship, you may make a FREE additional Fighter"
    // This is event-triggered, not directly executable
    // Should be handled by ship completion events
    return { gameState: context.gameState };
  },
  
  // TACTICAL CRUISER (TAC) - TYPE-based damage
  'TAC_0': (power, context) => {
    // "Automatic: Deal 1 damage for each TYPE of ship you have"
    // TYPE = unique ship definition IDs (including TAC itself)
    const { gameState, ownerId, opponentId, ship } = context;
    
    // Count unique ship types (alive ships only)
    const ships = gameState.gameData.ships[ownerId] || [];
    const aliveShips = ships.filter(s => !s.isDestroyed && !s.isConsumedInUpgrade);
    const uniqueTypes = new Set(aliveShips.map(s => s.shipId));
    const typeCount = uniqueTypes.size;
    
    // Create damage effect
    const effect = createTriggeredEffect({
      id: generateEffectId(
        {
          sourcePlayerId: ownerId,
          sourceShipInstanceId: ship.id,
          sourceShipDefId: ship.shipId,
          sourcePowerIndex: power.powerIndex,
          sourceType: 'ship_power'
        },
        EffectKind.DAMAGE,
        gameState.roundNumber,
        0
      ),
      kind: EffectKind.DAMAGE,
      source: {
        sourcePlayerId: ownerId,
        sourceShipInstanceId: ship.id,
        sourceShipDefId: ship.shipId,
        sourcePowerIndex: power.powerIndex,
        sourceType: 'ship_power'
      },
      target: createOpponentTarget(ownerId, gameState.players),
      value: typeCount,
      description: `Tactical Cruiser: ${typeCount} ship types`
    });
    
    return {
      gameState,
      effects: [effect],
      description: `Counted ${typeCount} ship types`
    };
  },
  
  // -------------------------------------------------------------------------
  // XENITE SHIPS
  // -------------------------------------------------------------------------
  
  // EVOLVER (EVO) - Ship transformation
  'EVO_0': (power, context) => {
    // "May turn one Xenite into an Oxite or an Asterite"
    // Requires player choice
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose Xenite to evolve and target form'
    };
  },
  
  // ZENITH (ZEN) - Complex conditional build
  'ZEN_1': (power, context) => {
    // "If dice roll is a 2, make a Xenite. If 3, make Antlion. If 4, make two Xenites"
    const { diceRoll, gameState } = context;
    
    if (!diceRoll || diceRoll < 2 || diceRoll > 4) {
      return { gameState };
    }
    
    // This would trigger ship creation based on dice
    // Actual implementation would use ship build system
    return {
      gameState,
      description: `Zenith triggered on dice ${diceRoll}`,
      requiresChoice: false
    };
  },
  
  // DEFENSE SWARM (DSW) - Conditional healing
  'DSW_0': (power, context) => {
    // "Heal 3 OR if health lower than opponent: Heal 7"
    const { gameState, ownerId } = context;
    
    const player = gameState.players.find(p => p.id === ownerId);
    const opponent = gameState.players.find(p => p.id !== ownerId);
    
    if (!player || !opponent) {
      return { gameState };
    }
    
    const healAmount = player.health < opponent.health ? 7 : 3;
    
    const effect = createTriggeredEffect({
      id: generateEffectId(
        {
          sourcePlayerId: ownerId,
          sourceShipInstanceId: context.ship.id,
          sourceShipDefId: context.ship.shipId,
          sourcePowerIndex: power.powerIndex,
          sourceType: 'ship_power'
        },
        EffectKind.HEAL,
        gameState.roundNumber,
        0
      ),
      kind: EffectKind.HEAL,
      source: {
        sourcePlayerId: ownerId,
        sourceShipInstanceId: context.ship.id,
        sourceShipDefId: context.ship.shipId,
        sourcePowerIndex: power.powerIndex,
        sourceType: 'ship_power'
      },
      target: createSelfTarget(ownerId),
      value: healAmount,
      description: `Defense Swarm: Heal ${healAmount}`
    });
    
    return {
      gameState,
      effects: [effect],
      description: `Healed ${healAmount} (conditional)`
    };
  },
  
  // SACRIFICIAL POOL (SAC) - Destroy own ship for xenites
  'SAC_0': (power, context) => {
    // "May destroy one basic ship of yours and make a Xenite for every 3 lines"
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose ship to sacrifice'
    };
  },
  
  // QUEEN (QUE) - Count ships built this turn
  'QUE_1': (power, context) => {
    // "Deal 3 damage for each ship you made this turn"
    // Requires tracking ships built this turn
    // For now, return no-op (needs turn tracking)
    console.warn('[ManualOverrides] QUE_1 requires ship build tracking (not yet implemented)');
    return { gameState: context.gameState };
  },
  
  // -------------------------------------------------------------------------
  // CENTAUR SHIPS
  // -------------------------------------------------------------------------
  
  // SHIP OF EQUALITY (EQU) - Destroy matching ships
  'EQU_0': (power, context) => {
    // "Destroy one basic ship of yours, and one basic ship of opponent's with EQUAL lines"
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose two ships with equal line cost'
    };
  },
  
  // SHIP OF VIGOR (VIG) - Conditional on dice
  'VIG_0': (power, context) => {
    const { diceRoll, gameState, ownerId } = context;
    
    // "If dice roll is even (2, 4, 6) generate TWO additional lines"
    if (!diceRoll || diceRoll % 2 !== 0) {
      return { gameState };
    }
    
    const updatedState = {
      ...gameState,
      players: gameState.players.map(p =>
        p.id === ownerId
          ? { ...p, lines: (p.lines || 0) + 2 }
          : p
      )
    };
    
    return {
      gameState: updatedState,
      description: `Ship of Vigor: +2 lines (dice: ${diceRoll})`
    };
  },
  
  // ARK OF KNOWLEDGE (KNO) - Reroll mechanic
  'KNO_0': (power, context) => {
    // "May reroll the dice"
    // Handled by dice manipulation system
    return { gameState: context.gameState };
  },
  
  'KNO_2': (power, context) => {
    // "If you have 3 Arks: damage and healing equal to whichever is higher"
    // This is a passive modifier
    return { gameState: context.gameState };
  },
  
  // ARK OF DOMINATION (DOM) - Take control of ships
  'DOM_1': (power, context) => {
    // "Take permanent control of TWO basic enemy ships"
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose two basic enemy ships to steal'
    };
  },
  
  // -------------------------------------------------------------------------
  // ANCIENT SHIPS
  // -------------------------------------------------------------------------
  
  // QUANTUM MYSTIC (QUA) - Conditional on dice
  'QUA_0': (power, context) => {
    const { diceRoll, gameState, ownerId } = context;
    
    // "If dice roll is 1 or 2: Gain 1 blue energy"
    if (!diceRoll || (diceRoll !== 1 && diceRoll !== 2)) {
      return { gameState };
    }
    
    const updatedState = {
      ...gameState,
      players: gameState.players.map(p => {
        if (p.id !== ownerId) return p;
        const energy = p.energy || { red: 0, green: 0, blue: 0 };
        return {
          ...p,
          energy: { ...energy, blue: energy.blue + 1 }
        };
      })
    };
    
    return {
      gameState: updatedState,
      description: 'Quantum Mystic: +1 blue energy'
    };
  },
  
  'QUA_1': (power, context) => {
    const { diceRoll, gameState, ownerId } = context;
    
    // "If dice roll is 1 or 2: heal 5"
    if (!diceRoll || (diceRoll !== 1 && diceRoll !== 2)) {
      return { gameState };
    }
    
    const effect = createTriggeredEffect({
      id: generateEffectId(
        {
          sourcePlayerId: ownerId,
          sourceShipInstanceId: context.ship.id,
          sourceShipDefId: context.ship.shipId,
          sourcePowerIndex: power.powerIndex,
          sourceType: 'ship_power'
        },
        EffectKind.HEAL,
        gameState.roundNumber,
        0
      ),
      kind: EffectKind.HEAL,
      source: {
        sourcePlayerId: ownerId,
        sourceShipInstanceId: context.ship.id,
        sourceShipDefId: context.ship.shipId,
        sourcePowerIndex: power.powerIndex,
        sourceType: 'ship_power'
      },
      target: createSelfTarget(ownerId),
      value: 5,
      description: 'Quantum Mystic: Heal 5'
    });
    
    return {
      gameState,
      effects: [effect],
      description: 'Quantum Mystic heal triggered'
    };
  },
  
  // SPIRAL (SPI) - Conditional based on count
  'SPI_0': (power, context) => {
    // "If you have one: Heal 1 for each red and/or green energy spent this turn"
    // Requires tracking energy spent this turn
    console.warn('[ManualOverrides] SPI_0 requires energy tracking (not yet implemented)');
    return { gameState: context.gameState };
  },
  
  'SPI_2': (power, context) => {
    // "If you have three: Deal 1 damage for each red and/or green energy spent"
    console.warn('[ManualOverrides] SPI_2 requires energy tracking (not yet implemented)');
    return { gameState: context.gameState };
  },
  
  // CUBE (CUB) - Repeat solar power
  'CUB_0': (power, context) => {
    // "Once per turn, you may repeat a solar power that you cast"
    return {
      gameState: context.gameState,
      requiresChoice: true,
      description: 'Player must choose which solar power to repeat'
    };
  },
};

// ============================================================================
// PUBLIC API
// ============================================================================

/**
 * Get manual override handler for a specific ship power
 * @returns Handler function if override exists, undefined otherwise
 */
export function getManualOverride(
  shipId: ShipDefId,
  powerIndex: number
): ManualPowerHandler | undefined {
  const key = `${shipId}_${powerIndex}`;
  return MANUAL_OVERRIDES[key];
}

/**
 * Check if a power has a manual override
 */
export function hasManualOverride(
  shipId: ShipDefId,
  powerIndex: number
): boolean {
  return getManualOverride(shipId, powerIndex) !== undefined;
}

/**
 * Execute a manual override
 * @throws Error if no override exists for this power
 */
export function executeManualOverride(
  shipId: ShipDefId,
  powerIndex: number,
  power: EngineShipPower,
  context: PowerExecutionContext
): ManualPowerResult {
  const handler = getManualOverride(shipId, powerIndex);
  
  if (!handler) {
    throw new Error(
      `No manual override exists for ${shipId}_${powerIndex}. ` +
      `Check hasManualOverride() before calling.`
    );
  }
  
  return handler(power, context);
}

/**
 * Get statistics about manual overrides
 * Useful for tracking progress toward structured interpretation
 */
export function getOverrideStats() {
  const totalOverrides = Object.keys(MANUAL_OVERRIDES).length;
  const shipIds = new Set<string>();
  
  for (const key of Object.keys(MANUAL_OVERRIDES)) {
    const shipId = key.split('_')[0];
    shipIds.add(shipId);
  }
  
  return {
    totalOverrides,
    uniqueShips: shipIds.size,
    shipList: Array.from(shipIds).sort()
  };
}