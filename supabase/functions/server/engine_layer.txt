// ============================================================================
// ENGINE COMPATIBILITY LAYER  
// ============================================================================
// Since we cannot easily import /game/engine/* files into Deno edge function,
// we inline essential validation and application logic here.
// This is the AUTHORITATIVE game logic - all mutations flow through these functions.
// 
// CRITICAL: Keep this synchronized with the real GameEngine to prevent rule drift.
// Future improvement: Bundle engine code for Deno import.
// ============================================================================

class IntentEngine {
  // Validate BUILD_REVEAL payload atomically
  static validateBuildReveal(gameState, playerId, payload, turnNumber) {
    const player = gameState.players.find(p => p.id === playerId);
    if (!player) {
      return { valid: false, code: 'PLAYER_NOT_FOUND', message: 'Player not in game' };
    }

    if (!payload.buildShips && !payload.saveLines) {
      return { valid: true }; // Empty payload is valid (pass)
    }

    let totalCost = 0;

    if (payload.buildShips) {
      for (const shipReq of payload.buildShips) {
        const shipDef = getShipDef(shipReq.shipDefId);
        if (!shipDef) {
          return { valid: false, code: 'INVALID_SHIP_DEF', message: `Ship ${shipReq.shipDefId} not found` };
        }

        // Calculate cost
        const shipCost = shipReq.lineCost !== undefined 
          ? shipReq.lineCost 
          : (shipDef.type === 'basic' ? shipDef.buildCost : 0);
        const joiningCost = shipReq.joiningLineCost !== undefined
          ? shipReq.joiningLineCost
          : (shipDef.type === 'upgraded' ? shipDef.joiningCost : 0);
        
        totalCost += shipCost + joiningCost;

        // Validate sacrifice for upgraded ships
        if (shipDef.type === 'upgraded' && shipDef.requiresSacrifice) {
          const requiredCount = shipDef.requiresSacrifice.length;
          const providedCount = shipReq.consumeShipInstanceIds?.length || 0;
          
          if (providedCount !== requiredCount) {
            return { 
              valid: false, 
              code: 'INVALID_SACRIFICE', 
              message: `${shipDef.name} requires ${requiredCount} sacrifices, got ${providedCount}` 
            };
          }

          // Validate sacrificed ships exist and match types
          const playerShips = gameState.gameData?.ships?.[playerId] || [];
          for (const sacrificeId of shipReq.consumeShipInstanceIds) {
            const ship = playerShips.find(s => s.shipInstanceId === sacrificeId && !s.isDestroyed);
            if (!ship) {
              return { 
                valid: false, 
                code: 'SACRIFICE_NOT_FOUND', 
                message: `Sacrificed ship ${sacrificeId} not found or already destroyed` 
              };
            }

            // Validate ship type matches requirement
            const requiredTypes = shipDef.requiresSacrifice;
            if (!requiredTypes.includes(ship.shipDefId)) {
              return { 
                valid: false, 
                code: 'WRONG_SACRIFICE_TYPE', 
                message: `${shipDef.name} requires ${requiredTypes.join('/')} but got ${ship.shipDefId}` 
              };
            }
          }
        }
      }
    }

    // Validate player has enough lines
    const availableLines = player.lines || 0;
    if (totalCost > availableLines) {
      return { 
        valid: false, 
        code: 'INSUFFICIENT_LINES', 
        message: `Need ${totalCost} lines, have ${availableLines}` 
      };
    }

    return { valid: true, totalCost };
  }

  // Apply BUILD_REVEAL atomically - returns { newState, events, createdShipIds, destroyedShipIds }
  static applyBuildReveal(gameState, playerId, payload, turnNumber) {
    const events = [];
    const createdShipIds = [];
    const destroyedShipIds = [];
    const updatedShipIds = [];

    // Initialize ships structure if needed
    if (!gameState.gameData.ships) {
      gameState.gameData.ships = {};
    }
    if (!gameState.gameData.ships[playerId]) {
      gameState.gameData.ships[playerId] = [];
    }

    const player = gameState.players.find(p => p.id === playerId);
    let totalCost = 0;

    // Process ship builds
    if (payload.buildShips) {
      for (const shipReq of payload.buildShips) {
        const shipDef = getShipDef(shipReq.shipDefId);
        
        // Calculate cost
        const shipCost = shipReq.lineCost !== undefined 
          ? shipReq.lineCost 
          : (shipDef.type === 'basic' ? shipDef.buildCost : 0);
        const joiningCost = shipReq.joiningLineCost !== undefined
          ? shipReq.joiningLineCost
          : (shipDef.type === 'upgraded' ? shipDef.joiningCost : 0);
        
        totalCost += shipCost + joiningCost;

        // Create ship instance
        const shipInstanceId = crypto.randomUUID();
        const newShip = {
          shipInstanceId,
          shipDefId: shipDef.id,
          ownerId: playerId,
          isDestroyed: false,
          createdAtTurn: turnNumber,
          name: shipDef.name,
          species: shipDef.species,
          type: shipDef.type,
          // TODO: Add ship powers, charges, etc. from full engine
        };

        gameState.gameData.ships[playerId].push(newShip);
        createdShipIds.push(shipInstanceId);

        // Handle sacrifices
        if (shipReq.consumeShipInstanceIds) {
          for (const sacrificeId of shipReq.consumeShipInstanceIds) {
            const ship = gameState.gameData.ships[playerId].find(s => s.shipInstanceId === sacrificeId);
            if (ship && !ship.isDestroyed) {
              ship.isDestroyed = true;
              ship.destroyedAtTurn = turnNumber;
              destroyedShipIds.push(sacrificeId);
            }
          }
        }

        // Handle ship configurations
        if (payload.configureShips) {
          const config = payload.configureShips.find(c => c.shipInstanceId === shipInstanceId);
          if (config) {
            if (!newShip.configuration) {
              newShip.configuration = {};
            }
            newShip.configuration[config.key] = config.value;
            updatedShipIds.push(shipInstanceId);
          }
        }
      }
    }

    // Deduct lines atomically
    player.lines = (player.lines || 0) - totalCost;

    // Generate SHIPS_CHANGED event with actual IDs
    if (createdShipIds.length > 0 || destroyedShipIds.length > 0 || updatedShipIds.length > 0) {
      const shipChangedEvent = {
        type: 'SHIPS_CHANGED',
        playerId: playerId
      };
      
      if (createdShipIds.length > 0) shipChangedEvent.created = createdShipIds;
      if (destroyedShipIds.length > 0) shipChangedEvent.destroyed = destroyedShipIds;
      if (updatedShipIds.length > 0) shipChangedEvent.updated = updatedShipIds;
      
      events.push(shipChangedEvent);
    }

    return {
      newState: gameState,
      events,
      createdShipIds,
      destroyedShipIds,
      updatedShipIds
    };
  }

  // Validate ACTION intent
  static validateAction(gameState, playerId, intent) {
    const currentPhase = gameState.gameData?.turnData?.currentMajorPhase;
    const currentStep = gameState.gameData?.turnData?.currentStep;
    
    // Validate player is in game
    const player = gameState.players.find(p => p.id === playerId);
    if (!player) {
      return { valid: false, code: 'PLAYER_NOT_FOUND', message: 'Player not in game' };
    }

    // Validate phase matches
    if (intent.phase !== currentPhase) {
      return { 
        valid: false, 
        code: 'WRONG_PHASE', 
        message: `Action for ${intent.phase} but current phase is ${currentPhase}` 
      };
    }

    // Validate step if provided
    if (intent.step && intent.step !== currentStep) {
      return { 
        valid: false, 
        code: 'WRONG_STEP', 
        message: `Action for ${intent.step} but current step is ${currentStep}` 
      };
    }

    // Validate actionType is recognized
    const validActionTypes = [
      'DICE_MANIPULATION',
      'ACTIVATE_CHARGE',
      'USE_SOLAR_POWER',
      'SACRIFICE_SHIP',
      'CONFIGURE_SHIP',
      'SELECT_TARGET'
    ];
    
    if (!validActionTypes.includes(intent.actionType)) {
      return { 
        valid: false, 
        code: 'UNKNOWN_ACTION_TYPE', 
        message: `Action type ${intent.actionType} not recognized` 
      };
    }

    // Type-specific validation
    switch (intent.actionType) {
      case 'ACTIVATE_CHARGE':
        if (!intent.data.shipInstanceId) {
          return { valid: false, code: 'MISSING_SHIP_ID', message: 'ACTIVATE_CHARGE requires shipInstanceId' };
        }
        break;
        
      case 'USE_SOLAR_POWER':
        if (!intent.data.solarPowerId) {
          return { valid: false, code: 'MISSING_POWER_ID', message: 'USE_SOLAR_POWER requires solarPowerId' };
        }
        break;
        
      case 'SACRIFICE_SHIP':
        if (!intent.data.shipInstanceId) {
          return { valid: false, code: 'MISSING_SHIP_ID', message: 'SACRIFICE_SHIP requires shipInstanceId' };
        }
        break;
        
      case 'CONFIGURE_SHIP':
        if (!intent.data.shipInstanceId || !intent.data.key) {
          return { valid: false, code: 'MISSING_CONFIG', message: 'CONFIGURE_SHIP requires shipInstanceId and key' };
        }
        break;
        
      case 'SELECT_TARGET':
        if (!intent.data.targetId) {
          return { valid: false, code: 'MISSING_TARGET', message: 'SELECT_TARGET requires targetId' };
        }
        break;
    }

    return { valid: true };
  }

  // Apply ACTION intent - returns { newState, events }
  static applyAction(gameState, playerId, intent) {
    const events = [];
    const turnNumber = gameState.gameData?.turnData?.turnNumber || 1;
    
    switch (intent.actionType) {
      case 'ACTIVATE_CHARGE':
        console.log(`âš¡ Player ${playerId} activating charge on ${intent.data.shipInstanceId}`);
        events.push({
          type: 'EFFECTS_QUEUED',
          effects: [{
            sourceShipId: intent.data.shipInstanceId,
            effectType: 'CHARGE_ACTIVATED',
          }]
        });
        break;
        
      case 'SACRIFICE_SHIP':
        const ships = gameState.gameData.ships?.[playerId] || [];
        const ship = ships.find(s => s.shipInstanceId === intent.data.shipInstanceId);
        if (ship) {
          ship.isDestroyed = true;
          ship.destroyedAtTurn = turnNumber;
          events.push({
            type: 'SHIPS_CHANGED',
            playerId: playerId,
            destroyed: [intent.data.shipInstanceId]
          });
        }
        break;
        
      case 'CONFIGURE_SHIP':
        const configShips = gameState.gameData.ships?.[playerId] || [];
        const configShip = configShips.find(s => s.shipInstanceId === intent.data.shipInstanceId);
        if (configShip) {
          if (!configShip.configuration) {
            configShip.configuration = {};
          }
          configShip.configuration[intent.data.key] = intent.data.value;
          events.push({
            type: 'SHIPS_CHANGED',
            playerId: playerId,
            updated: [intent.data.shipInstanceId]
          });
        }
        break;
    }

    return {
      newState: gameState,
      events
    };
  }

  // Validate BATTLE_REVEAL payload
  static validateBattleReveal(gameState, playerId, payload, window) {
    const player = gameState.players.find(p => p.id === playerId);
    if (!player) {
      return { valid: false, code: 'PLAYER_NOT_FOUND', message: 'Player not in game' };
    }

    // Validate charge declarations
    if (payload.charges) {
      for (const charge of payload.charges) {
        if (!charge.shipInstanceId) {
          return { valid: false, code: 'MISSING_SHIP_ID', message: 'Charge declaration requires shipInstanceId' };
        }
        
        const ships = gameState.gameData.ships?.[playerId] || [];
        const ship = ships.find(s => s.shipInstanceId === charge.shipInstanceId && !s.isDestroyed);
        if (!ship) {
          return { valid: false, code: 'SHIP_NOT_FOUND', message: `Ship ${charge.shipInstanceId} not found` };
        }
      }
    }

    return { valid: true };
  }

  // Apply BATTLE_REVEAL - returns { newState, events }
  static applyBattleReveal(gameState, playerId, payload, window) {
    const events = [];

    // Store battle actions for resolution
    if (!gameState.gameData.turnData.battleActions) {
      gameState.gameData.turnData.battleActions = {};
    }
    if (!gameState.gameData.turnData.battleActions[playerId]) {
      gameState.gameData.turnData.battleActions[playerId] = {};
    }
    
    gameState.gameData.turnData.battleActions[playerId][window] = payload;

    // Generate EFFECTS_QUEUED for declared actions
    const queuedEffects = [];
    
    if (payload.charges) {
      for (const charge of payload.charges) {
        queuedEffects.push({
          sourceShipId: charge.shipInstanceId,
          effectType: 'CHARGE',
          window: window,
        });
      }
    }
    
    if (payload.solarPowers) {
      for (const power of payload.solarPowers) {
        queuedEffects.push({
          solarPowerId: power.solarPowerId,
          effectType: 'SOLAR_POWER',
          window: window,
        });
      }
    }
    
    if (queuedEffects.length > 0) {
      events.push({
        type: 'EFFECTS_QUEUED',
        effects: queuedEffects
      });
    }

    return {
      newState: gameState,
      events
    };
  }
}
